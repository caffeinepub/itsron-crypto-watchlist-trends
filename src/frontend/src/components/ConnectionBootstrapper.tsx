import { useEffect, useState } from 'react';
import { AlertCircle, RefreshCw, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Actor, HttpAgent } from '@dfinity/agent';
import type { backendInterface } from '../backend';
import type { IDL } from '@dfinity/candid';

interface ConnectionBootstrapperProps {
  children: React.ReactNode;
}

type ConnectionState = 'connecting' | 'connected' | 'error';

// Exponential backoff configuration
const RETRY_CONFIG = {
  maxAttempts: 10,
  initialDelayMs: 500,
  maxDelayMs: 10000,
  backoffMultiplier: 1.5,
};

// Sleep utility
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Calculate delay with exponential backoff
function calculateBackoffDelay(attempt: number): number {
  const delay = RETRY_CONFIG.initialDelayMs * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);
  return Math.min(delay, RETRY_CONFIG.maxDelayMs);
}

// Detect if running on local network
function isLocalNetwork(): boolean {
  const host = window.location.hostname;
  return host === 'localhost' || host === '127.0.0.1' || host.includes('localhost');
}

// Get the appropriate host for the network
function getHost(): string {
  const isLocal = isLocalNetwork();
  return isLocal ? 'http://127.0.0.1:4943' : 'https://icp-api.io';
}

// Validate canister ID format
function validateCanisterId(canisterId: string): boolean {
  if (!canisterId || typeof canisterId !== 'string') return false;
  // Canister IDs are base32-encoded and contain lowercase letters, numbers, and hyphens
  return /^[a-z0-9-]+$/.test(canisterId) && canisterId.length >= 5;
}

// Get backend canister ID from multiple possible sources
function getBackendCanisterId(): string | null {
  // Check localStorage first for cached canister ID
  const cachedCanisterId = localStorage.getItem('backend_canister_id');
  if (cachedCanisterId && validateCanisterId(cachedCanisterId)) {
    console.log(`âœ“ Using cached canister ID: ${cachedCanisterId}`);
    return cachedCanisterId;
  }

  // Try environment variables (Vite format)
  const envVars = [
    import.meta.env.VITE_CANISTER_ID_BACKEND,
    import.meta.env.VITE_BACKEND_CANISTER_ID,
    import.meta.env.CANISTER_ID_BACKEND,
    import.meta.env.BACKEND_CANISTER_ID,
  ];

  for (const envVar of envVars) {
    if (envVar && typeof envVar === 'string' && validateCanisterId(envVar)) {
      // Cache the valid canister ID
      localStorage.setItem('backend_canister_id', envVar);
      return envVar;
    }
  }

  // Try to load from canister_ids.json (for local development)
  try {
    // @ts-ignore - This file is generated by dfx
    const canisterIds = import.meta.env.VITE_CANISTER_IDS;
    if (canisterIds) {
      const parsed = typeof canisterIds === 'string' ? JSON.parse(canisterIds) : canisterIds;
      const canisterId = parsed?.backend?.local || parsed?.backend?.ic;
      if (canisterId && validateCanisterId(canisterId)) {
        // Cache the valid canister ID
        localStorage.setItem('backend_canister_id', canisterId);
        return canisterId;
      }
    }
  } catch (error) {
    console.warn('Failed to parse canister IDs from environment:', error);
  }

  return null;
}

// Wait for canister ID with retry logic
async function waitForCanisterId(): Promise<string> {
  for (let attempt = 0; attempt < RETRY_CONFIG.maxAttempts; attempt++) {
    const canisterId = getBackendCanisterId();
    
    if (canisterId && validateCanisterId(canisterId)) {
      console.log(`âœ“ Backend canister ID detected: ${canisterId}`);
      return canisterId;
    }

    if (attempt < RETRY_CONFIG.maxAttempts - 1) {
      const delay = calculateBackoffDelay(attempt);
      console.log(
        `â³ Waiting for canister ID... (attempt ${attempt + 1}/${RETRY_CONFIG.maxAttempts}, retry in ${Math.round(delay)}ms)`
      );
      await sleep(delay);
    }
  }

  throw new Error(
    'Backend canister ID not found after multiple retries. ' +
    'Please ensure the backend is deployed and dfx generate has been run.'
  );
}

// Verify backend connection with retry logic
async function verifyBackendConnection(canisterId: string, agent: HttpAgent): Promise<boolean> {
  try {
    // Import the backend module dynamically
    const backendModule = await import('../backend');
    
    // Get idlFactory - it should be exported from the generated backend module
    const idlFactory = (backendModule as any).idlFactory as IDL.InterfaceFactory;
    
    if (!idlFactory) {
      console.error('idlFactory not found in backend module');
      return false;
    }

    const actor = Actor.createActor<backendInterface>(idlFactory, {
      agent,
      canisterId,
    });

    // Try to check if caller is admin as a health check (public query)
    await actor.isCallerAdmin();
    console.log('âœ“ Backend connection verified');
    return true;
  } catch (error) {
    console.warn('Backend connection verification failed:', error);
    return false;
  }
}

// Get configuration status for debugging
function getConfigStatus() {
  const canisterId = getBackendCanisterId();
  return {
    isInitialized: !!canisterId,
    canisterId: canisterId || null,
    isValid: canisterId ? validateCanisterId(canisterId) : false,
    isLocal: isLocalNetwork(),
    host: getHost(),
    envVars: {
      VITE_CANISTER_ID_BACKEND: import.meta.env.VITE_CANISTER_ID_BACKEND || null,
      VITE_BACKEND_CANISTER_ID: import.meta.env.VITE_BACKEND_CANISTER_ID || null,
      CANISTER_ID_BACKEND: import.meta.env.CANISTER_ID_BACKEND || null,
      BACKEND_CANISTER_ID: import.meta.env.BACKEND_CANISTER_ID || null,
    },
  };
}

// Create actor with configuration and retry logic
async function createActorWithConfig(): Promise<backendInterface> {
  // Wait for canister ID with retry logic
  const canisterId = await waitForCanisterId();

  // Determine host
  const host = getHost();
  const isLocal = isLocalNetwork();

  console.log(`â†’ Creating actor with canister ID: ${canisterId}`);
  console.log(`â†’ Network: ${isLocal ? 'Local' : 'Internet Computer'}`);
  console.log(`â†’ Host: ${host}`);

  // Create HTTP agent
  const agent = new HttpAgent({ host });

  // Fetch root key for local development
  if (isLocal) {
    try {
      await agent.fetchRootKey();
      console.log('âœ“ Root key fetched for local development');
    } catch (error) {
      console.warn('Failed to fetch root key:', error);
    }
  }

  // Verify connection with retry logic
  let connectionVerified = false;
  for (let attempt = 0; attempt < 3; attempt++) {
    connectionVerified = await verifyBackendConnection(canisterId, agent);
    if (connectionVerified) break;
    
    if (attempt < 2) {
      const delay = calculateBackoffDelay(attempt);
      console.log(`â³ Retrying connection verification... (attempt ${attempt + 2}/3)`);
      await sleep(delay);
    }
  }

  if (!connectionVerified) {
    throw new Error(
      'Failed to verify backend connection. Please ensure the backend canister is deployed and running.'
    );
  }

  // Import IDL factory dynamically
  const backendModule = await import('../backend');
  const idlFactory = (backendModule as any).idlFactory as IDL.InterfaceFactory;

  if (!idlFactory) {
    throw new Error('idlFactory not found in backend module. Please run dfx generate backend.');
  }

  // Create and return actor
  const actor = Actor.createActor<backendInterface>(idlFactory, {
    agent,
    canisterId,
  });

  console.log('âœ“ Actor created successfully');
  return actor;
}

export default function ConnectionBootstrapper({ children }: ConnectionBootstrapperProps) {
  const [connectionState, setConnectionState] = useState<ConnectionState>('connecting');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [isRetrying, setIsRetrying] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const [connectionAttempt, setConnectionAttempt] = useState(0);

  // Initialize connection on mount
  useEffect(() => {
    let mounted = true;

    const initializeConnection = async () => {
      try {
        setConnectionState('connecting');
        setErrorMessage(null);

        console.log('ðŸ”„ Initializing backend connection...');
        
        // Create actor with retry logic - this will verify the connection
        await createActorWithConfig();
        
        if (!mounted) return;

        setConnectionState('connected');
        console.log('âœ“ Connection bootstrapper: Backend ready');
      } catch (error) {
        if (!mounted) return;
        
        const status = getConfigStatus();
        setConnectionState('error');
        
        if (error instanceof Error) {
          setErrorMessage(error.message);
        } else {
          setErrorMessage(
            status.canisterId
              ? `Invalid canister ID format: ${status.canisterId}`
              : 'Backend canister ID is missing. Please ensure the backend is deployed.'
          );
        }
        
        console.error('âŒ Connection bootstrapper error:', error);
      }
    };

    initializeConnection();

    return () => {
      mounted = false;
    };
  }, [connectionAttempt]);

  const handleRetry = async () => {
    setIsRetrying(true);
    
    // Wait a moment before retrying
    await new Promise(resolve => setTimeout(resolve, 500));
    
    setRetryCount(prev => prev + 1);
    setConnectionAttempt(prev => prev + 1);
    setIsRetrying(false);
  };

  const handleReload = () => {
    // Clear cached canister ID before reload
    localStorage.removeItem('backend_canister_id');
    window.location.reload();
  };

  // Show loading state while connecting
  if (connectionState === 'connecting') {
    return (
      <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-background via-background to-accent/10">
        <div className="text-center space-y-4 max-w-md px-4">
          <Loader2 className="h-12 w-12 animate-spin text-primary mx-auto" />
          <div className="space-y-2">
            <p className="text-lg font-medium">Connecting to backend...</p>
            <p className="text-sm text-muted-foreground">
              Establishing connection to the Internet Computer
            </p>
            {retryCount > 0 && (
              <p className="text-xs text-muted-foreground">
                Retry attempt: {retryCount}
              </p>
            )}
          </div>
        </div>
      </div>
    );
  }

  // Show error state
  if (connectionState === 'error') {
    const status = getConfigStatus();

    return (
      <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-background via-background to-accent/10 p-4">
        <div className="w-full max-w-2xl space-y-4">
          <Alert variant="destructive">
            <AlertCircle className="h-5 w-5" />
            <AlertTitle className="text-lg font-semibold">Connection Error</AlertTitle>
            <AlertDescription className="mt-2 space-y-3">
              <p className="text-sm">{errorMessage}</p>
              
              <div className="rounded-md bg-destructive/10 p-3 text-xs space-y-2">
                <div>
                  <p className="font-semibold mb-1">Current Configuration:</p>
                  <ul className="list-disc list-inside space-y-1 ml-2">
                    <li>Network: <span className="font-mono">{status.isLocal ? 'Local' : 'Internet Computer'}</span></li>
                    <li>Host: <span className="font-mono">{status.host}</span></li>
                    <li>Canister ID: <span className="font-mono">{status.canisterId || 'Not found'}</span></li>
                    <li>Valid: <span className="font-mono">{status.isValid ? 'Yes' : 'No'}</span></li>
                    <li>Initialized: <span className="font-mono">{status.isInitialized ? 'Yes' : 'No'}</span></li>
                  </ul>
                </div>

                <div>
                  <p className="font-semibold mb-1">Environment Variables Checked:</p>
                  <ul className="list-disc list-inside space-y-1 ml-2 text-[10px]">
                    {Object.entries(status.envVars).map(([key, value]) => (
                      <li key={key}>
                        <code className="bg-background/50 px-1 py-0.5 rounded">{key}</code>: 
                        <span className="ml-1 font-mono">{String(value || 'not set')}</span>
                      </li>
                    ))}
                  </ul>
                </div>

                <div>
                  <p className="font-semibold mb-2">Troubleshooting steps:</p>
                  <ol className="list-decimal list-inside space-y-1 ml-2">
                    <li>Ensure the backend canister is deployed:
                      <code className="block bg-background/50 px-2 py-1 rounded mt-1 ml-4">dfx deploy backend</code>
                    </li>
                    <li>Check that canister IDs are generated:
                      <code className="block bg-background/50 px-2 py-1 rounded mt-1 ml-4">dfx canister id backend</code>
                    </li>
                    <li>Verify dfx generate was run:
                      <code className="block bg-background/50 px-2 py-1 rounded mt-1 ml-4">dfx generate backend</code>
                    </li>
                    {status.isLocal && (
                      <li>For local development, ensure dfx is running:
                        <code className="block bg-background/50 px-2 py-1 rounded mt-1 ml-4">dfx start --background</code>
                      </li>
                    )}
                    <li>After deploying, restart the development server:
                      <code className="block bg-background/50 px-2 py-1 rounded mt-1 ml-4">npm run start</code>
                    </li>
                  </ol>
                </div>
              </div>
            </AlertDescription>
          </Alert>

          <div className="flex gap-3">
            <Button
              onClick={handleRetry}
              disabled={isRetrying}
              className="flex-1"
              variant="default"
            >
              {isRetrying ? (
                <>
                  <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
                  Retrying...
                </>
              ) : (
                <>
                  <RefreshCw className="mr-2 h-4 w-4" />
                  Retry Connection
                </>
              )}
            </Button>
            <Button
              onClick={handleReload}
              variant="outline"
              className="flex-1"
            >
              Reload Page
            </Button>
          </div>

          <div className="text-center text-sm text-muted-foreground space-y-1">
            <p>Need help? Check the console for more details.</p>
            {retryCount > 0 && (
              <p className="text-xs">Retry attempts: {retryCount}</p>
            )}
          </div>
        </div>
      </div>
    );
  }

  // Connection is ready, render children
  return <>{children}</>;
}

